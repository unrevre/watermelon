#!/usr/bin/env python
# pylint: disable=missing-docstring,invalid-name

import re
import sys
import textwrap

BITS = 128

FILES = 9
RANKS = 10

class Mask():
    def __init__(self):
        self.bits = bytearray(128)

    def __str__(self):
        strrep = ''.join((str(b) for b in self.bits[::-1]))
        hexrep = (hex(int(strrep[:64], 2)), hex(int(strrep[64:], 2)))
        return '(((__uint128_t){}) << 64) + {}'.format(hexrep[0], hexrep[1])

    def clear(self):
        self.bits = bytearray(128)

    def fill(self, index, count, value):
        for i in range(count):
            self.bits[index + i] = value


class Board(Mask):
    def __init__(self, sentinel):
        super().__init__()
        self.sentinel = sentinel
        self.width = FILES + 2 * self.sentinel
        self.height = RANKS

    def index(self, x, y):
        return y * self.width + self.sentinel + x

    def layout_board(self):
        for y in range(self.height):
            self.fill(self.index(0, y), FILES, 1)

    def layout_jmask(self, side):
        h = self.height - 3 if side else 0
        for y in range(h, h + 3):
            self.fill(self.index(3, y), 3, 1)

    def layout_smask(self, side):
        h = self.height - 3 if side else 0
        for x, y in ((3, h), (5, h), (4, h + 1), (3, h + 2), (5, h + 2)):
            self.fill(self.index(x, y), 1, 1)

    def layout_xmask(self, side):
        h = self.height - 5 if side else 0
        for x, y in ((2, h), (6, h), (0, h + 2), (4, h + 2), (8, h + 2),
                     (2, h + 4), (6, h + 4)):
            self.fill(self.index(x, y), 1, 1)

    def layout_zmask(self, side):
        h = self.height - 5 if side else 3
        for y in range(h, h + 2):
            for x, y in ((0, y), (2, y), (4, y), (6, y), (8, y)):
                self.fill(self.index(x, y), 1, 1)

        h = 0 if side else self.height - 5
        for y in range(h, h + 5):
            self.fill(self.index(0, y), FILES, 1)


def main():
    try:
        sentinel = int(sys.argv[1])
    except IndexError:
        sentinel = 0

    width = FILES + 2 * sentinel
    height = RANKS
    points = width * height

    mask = Mask()
    board = Board(sentinel)

    # templates
    typename = 'const __uint128_t'
    attr_align = '__attribute__((aligned(64)))'

    class clear_and_return():
        def __init__(self, mask):
            self.mask = mask

        def __call__(self, fn):
            def wrapped(*args):
                self.mask.clear()
                fn(*args)
                return self.mask
            return wrapped

    class format():
        def __call__(self, fn):
            def wrapped(identifier):
                f.write(identifier + ' =\n   ' + fn().__str__() + ';\n\n')
            return wrapped

    class array_format():
        def __init__(self, n):
            self.n = n

        def __call__(self, fn):
            def wrapped(identifier):
                f.write(identifier + ' = {\n')
                for i in range(self.n):
                    f.write('   ' + fn(i).__str__() + ',\n')
                f.truncate(f.tell() - 2)
                f.write('\n};\n\n')
            return wrapped

    # generate source (.c) file
    output = 'masks.c'

    with open(output, 'a') as f:
        f.write(textwrap.dedent(
            """
            /* auto-generated by maskgen.py */
            #include "masks.h"

            """))

        # board mask    [BMASK]
        @format()
        @clear_and_return(board)
        def etch_board_mask():
            board.layout_board()

        etch_board_mask('{} BMASK'.format(typename))

        # point masks   [PMASK]
        @array_format(BITS)
        @clear_and_return(mask)
        def etch_point_masks(i):
            mask.fill(i, 1, 1)

        etch_point_masks('{} PMASK[BITS] {}'.format(typename, attr_align))

        # upper masks   [UMASK]
        @array_format(points)
        @clear_and_return(mask)
        def etch_upper_masks(i):
            mask.fill(i + 1, BITS - 1 - i, 1)

        etch_upper_masks('{} UMASK[POINTS] {}'.format(typename, attr_align))

        # lower masks   [LMASK]
        @array_format(points)
        @clear_and_return(mask)
        def etch_lower_masks(i):
            mask.fill(0, i, 1)

        etch_lower_masks('{} LMASK[POINTS] {}'.format(typename, attr_align))

        # rank masks    [RMASK]
        @array_format(points)
        @clear_and_return(mask)
        def etch_rank_masks(i):
            mask.fill((i // width) * width + sentinel, FILES, 1)

        etch_rank_masks('{} RMASK[POINTS] {}'.format(typename, attr_align))

        # file masks    [FMASK]
        @array_format(points)
        @clear_and_return(mask)
        def etch_file_masks(i):
            for y in range(RANKS):
                mask.fill(y * width + (i % width), 1, 1)

        etch_file_masks('{} FMASK[POINTS] {}'.format(typename, attr_align))

        # outer masks   [OMASK]
        @array_format(points)
        @clear_and_return(mask)
        def etch_outer_masks(i):
            for index in (i - (i % width), i - (i % width) + width - 1,
                          i % width, (RANKS - 1) * width + (i % width)):
                mask.fill(index, 1, 1)
            mask.fill(i, 1, 0)
            if not sentinel and i == 0:
                mask.fill(i, 1, 1)

        etch_outer_masks('{} OMASK[POINTS] {}'.format(typename, attr_align))

        # jiang mask    [JMASK]
        @array_format(2)
        @clear_and_return(board)
        def etch_jmasks(i):
            board.layout_jmask(i)

        etch_jmasks('{} JMASK[2]'.format(typename))

        # shi mask      [SMASK]
        @array_format(2)
        @clear_and_return(board)
        def etch_smasks(i):
            board.layout_smask(i)

        etch_smasks('{} SMASK[2]'.format(typename))

        # xiang mask    [XMASK]
        @array_format(2)
        @clear_and_return(board)
        def etch_xmasks(i):
            board.layout_xmask(i)

        etch_xmasks('{} XMASK[2]'.format(typename))

        # zu mask       [ZMASK]
        @array_format(2)
        @clear_and_return(board)
        def etch_zmasks(i):
            board.layout_zmask(i)

        etch_zmasks('{} ZMASK[2]'.format(typename))

        # special masks
        @format()
        @clear_and_return(mask)
        def etch_fmaskn0_mask():
            mask.fill(0, BITS, 1)
            for i in range(RANKS):
                mask.fill(i * width + sentinel, 1, 0)

        etch_fmaskn0_mask('{} FMASKN0'.format(typename))

        @format()
        @clear_and_return(mask)
        def etch_fmaskn8_mask():
            mask.fill(0, BITS, 1)
            for i in range(RANKS):
                mask.fill(i * width + sentinel + 8, 1, 0)

        etch_fmaskn8_mask('{} FMASKN8'.format(typename))

        @format()
        @clear_and_return(mask)
        def etch_fmaskn01_mask():
            mask.fill(0, BITS, 1)
            for i in range(RANKS):
                mask.fill(i * width + sentinel, 1, 0)
                mask.fill(i * width + sentinel + 1, 1, 0)

        etch_fmaskn01_mask('{} FMASKN01'.format(typename))

        @format()
        @clear_and_return(mask)
        def etch_fmaskn78_mask():
            mask.fill(0, BITS, 1)
            for i in range(RANKS):
                mask.fill(i * width + sentinel + 7, 1, 0)
                mask.fill(i * width + sentinel + 8, 1, 0)

        etch_fmaskn78_mask('{} FMASKN78'.format(typename))

    # generate header (.h) file
    output = re.sub(r'.c$', '.h', output)

    with open(output, 'a') as f:
        f.write(textwrap.dedent(
            """
            /* auto-generated by maskgen.py */
            #ifndef MASKS_H
            #define MASKS_H

            #include "magics.h"

            extern {0} BMASK;

            extern {0} PMASK[BITS];

            extern {0} UMASK[POINTS];
            extern {0} LMASK[POINTS];
            extern {0} RMASK[POINTS];
            extern {0} FMASK[POINTS];
            extern {0} OMASK[POINTS];

            extern {0} JMASK[2];
            extern {0} SMASK[2];
            extern {0} XMASK[2];
            extern {0} ZMASK[2];

            extern {0} FMASKN0;
            extern {0} FMASKN8;
            extern {0} FMASKN01;
            extern {0} FMASKN78;

            #endif /* MASKS_H */
            """.format(typename)))

if __name__ == '__main__':
    main()
